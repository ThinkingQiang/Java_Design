## 依赖倒置原则（六大原则中最小鸟依人的姑娘，对抽象的东西非常依赖）



#### **前言**

依赖抽象，不关注具体的实现，抽象接口的具体实现会根据需求做出相应的改变，
模块依赖于抽象，不需要关注具体的实现方法，比如：
Test测试类中，根据实际情况我们可以选择获取num数字的使用FileRead还是DbRead，因为他们都实现了Reader接口方法，
我们在使用中调用的都只是接口，而具体实现细节不关注，细节依赖于抽象。



#### 详解

​	原则描述的是高层模块不该依赖于低层模块，二者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。

​	上面黑色加粗这句话是这个原则的原版描述，我来解释下我自己的理解，这个原则描述的是一个现实当中的事实，即实现都是易变的，而只有抽象是稳定的，所以当依赖于抽象时，实现的变化并不会影响客户端的调用。 比如上述的计算器例子，我们的计算器其实是依赖于数据读取类的，这样做并不是很好，因为如果我的数据不是文件里的了，而是在数据库里，这样的话，为了不影响你现有的代码，你就只能将你的Reader类整个改头换面。

​	或者还有一种方式就是，你再添加一个DBReader类，然后把你所有使用Reader读取的地方，全部手动替换成DBReader，这样其实也还可以接受，那假设我有的从文件读取，有的从数据库读取，有的从XML文件读取，有的从网络中读取，有的从标准的键盘输入读取等等。

​	你想怎么办呢？

​	所以我们最好的做法就是抽象出一个抽象类或者是接口，来表述数据读取的行为，然后让上面所有的读取方式所实现的类都实现这个接口，而我们的客户端，只使用我们定义好的接口，当我们的实现变化时，我只需要设置不同的实际类型就可以了，这样对于系统的扩展性是一个大大的提升。

针对上面简单的数据读取，我们可以定义如下接口去描述。

```java
public interface Reader {  
    public int getA();   
    public int getB();  
}  
```

 让我们原来的Reader改名为FileReader去实现这个接口，这样计算器就依赖于抽象的接口，这个依赖是非常稳定的，因为不论你以后要从哪读取数据，你的两个获取数据的方法永远都不会变。

 这样，我们让DBReader，XMLReader，NETReader，StandardOutPutStreamReader等等，都可以实现Reader这个接口，而我们的客户端调用依赖于一个Reader，这样不管数据是从哪来的，我们都可以应对自如，因为我根本不关心你是什么Reader，我只知道你能让我获得A和B这两个值就行了。

 这便是我们依赖于抽象所得到的灵活性，这也是JAVA语言的动态特性给我们带来的便利，所以我们一定要好好珍惜这个依赖于抽象的姑娘。